// Christos Papadopoulos
// table2.template

// Implementation file for the Table class in table2 header file.

#include <cassert> // Provides ability to assert condtions.
#include "link2.h"
#include "table2.h"

using namespace std;

namespace CISP430_A6
{
	template <class RecordType>
	Table<RecordType>::Table()
	{
		//Class constructor: Constructs an empty table.

		for (size_t i = 0; i < TABLE_SIZE; ++i)
		{
			data[i] = NULL;
		}

		total_records = 0;
	}

	template <class RecordType>
	Table<RecordType>::Table(const Table& source)
	{
		// Copy constructor: Creates a copy of the con
		for (int i = 0; i < TABLE_SIZE; ++i)
		{
			Node<RecordType> *tail_ptr;
			list_copy(source.data[i], data[i], tail_ptr);
		}

		total_records = source.total_records;
	}

	template <class RecordType>
	Table<RecordType>::~Table()
	{
		// Table destructor.
		for (int i = 0; i < TABLE_SIZE; ++i)
		{
			list_clear(data[i]);
		}

		total_records = 0;
	}

	template<class RecordType>
	void Table<RecordType>::insert(const RecordType& entry)
	{
		// Function to insert new copy of entry into the table.
		if (is_present(entry.key) == false) // Check if the there is already an record in the table with the given key.
		{
			Node<RecordType> *cursor = data[hash(entry.key)]; //set cursor to head chain node

			if (cursor == NULL)
			{
				//create new head pointer (and set cursor to it)
				cursor = data[hash(entry.key)] = new Node<RecordType>;
				cursor->data = entry;
				cursor->link = NULL;
			}
			else
			{
				//first, find insert point
				while (cursor->link != NULL && cursor->data.key != entry.key)
				{
					cursor = cursor->link;
				} //cursor now contains last node in list

				cursor->link = new Node<RecordType>;
				//create new ptr, set values for new entry
				cursor = cursor->link;
				cursor->link = NULL;
				cursor->data = entry;
				//else - duplicate key - do not insert
			}

			total_records++; //new entry added -- increment count
		}
	}

	template<class RecordType>
	void Table<RecordType>::remove(int key)
	{
		// Function to remove the item at the given key.
		Node<RecordType> *cursor = data[hash(key)],
			*precursor = NULL;

		/* find node for deletion
		(cant use is_present since we need the node address) */
		bool found = false;
		while (cursor != NULL)
		{ //search for node containing key
			if (cursor->data.key == key)
			{ //node found -- time to delete
				found = true;
				break;
			}
			precursor = cursor;
			cursor = cursor->link;
		}
		if (found == true)
		{
			//unwanted node found -- time to delete
			//cursor contains node to be deleted
			list_remove(precursor);
			total_records--;
		}
		//else - no node to delete - do nothing
	}

	template<class RecordType>
	void Table<RecordType>::operator=(const Table & source)
	{
		if (this == &source) //handle self-assignment case
			return;

		clear(); //reset object -- prevent leaks
		Node<RecordType> *tempTail;

		//initialize and copy values
		for (int i = 0; i < TABLE_SIZE; i++)
		{ //list_copy(source, head, tail)
			list_copy(source.data[i], data[i], tempTail);
			//this->data[i] = tempHead; //set head for data set
		}
		this->total_records = source.total_records;
	}

	template<class RecordType>
	void Table<RecordType>::print(int index)
	{
		// Function to print out the records in the table.
		Node<RecordType> *cursor = data[index];
		//print header
		cout << "[( " << index << " )]----> ";
		while (cursor != NULL)
		{ //traverse nodes, printing each data key
			cout << "[" << cursor->data.key << "]-->";
			cursor = cursor->link;
		}
		cout << " NULL" << endl; //end node
	}

	template<class RecordType>
	void Table<RecordType>::clear()
	{
		// Function to clear the table.
		for (int i = 0; i < TABLE_SIZE; i++)
		{ //use toolkit clear on all indexes
			list_clear(data[i]);
		}
	}

	template<class RecordType>
	bool Table<RecordType>::is_present(int key) const
	{
		// Function to determine whether the target is in the table.
		Node<RecordType> *cursor = data[hash(key)];

		bool found = false;
		while (cursor != NULL)
		{
			if (cursor->data.key == key)
			{ //we have found our match
				found = true;
				break; //escape while loop
			}
			cursor = cursor->link; //advance list
		}
		return found;
	}

	template<class RecordType>
	void Table<RecordType>::find(int key, bool & found, RecordType & result) const
	{
		/*Postcondition: If a record is in the Table with the specified key, then found is true and result is set to a copy of the record with that key.  Otherwise found is false and the result contains garbage. */
		Node<RecordType> *cursor = data[hash(key)];

		found = false;
		while (cursor != NULL && cursor->data.key != key)
		{
			if (cursor->data.key == key)
			{ //we have found our match
				found = true;
				result = cursor->data;
				break;
			}
			//advance through list
			cursor = cursor->link;
		}
	}

	template<class RecordType>
	size_t Table<RecordType>::hash(int key) const
	{
		// Function to find the hash location of the given key.
		return key % TABLE_SIZE;
	}
}